# 2강. C++ 언어의 기초(1)

## 1. 키워드와 식별자

#### (1) 키워드

-  키워드(keyword)란?

  - C++ 언어에서 미리 용도를 정해놓은 단어 (`예약어` 라고도 부름)
  - 반드시 정해진 용도로만 사용해야 함

- 키워드의 예

  ```C++
  #include <iostream>
  using namespace std;
  int main()
  {
      cout << "나의 첫 번째 C++ 프로그램" << endl;
      return 0;
  }
  ```

  - 위의 코드에서 쓰인 키워드는 `using`, `namespace`, `int`, `return`이 있다.
  - `더 많은 키워드를 보려면 책 22page를 참고하자`

#### (2) 식별자 (1/2)

- 식별자(identifier)란?
  - 여러가지 대상을 구분하기 위해 만든 이름
    - 변수나 함수, 클래스 등의 이름
- 식별자를 만드는 규칙
  - 첫 자는 비숫자 문자를 사용함`(C++11 : 다국어 문자 포함)`
  - 이후의 문자`는 `비숫자 문자`와 `숫자`를 사용함
  - `길이 제한은 없음`
  - `특수문자는 포함할 수 없음`
  - `키워드`는 `식별자로 사용할 수 없음`

#### (2) 식별자 (2/2)

- 식별자의 예
  - abc
  - myname
  - myName(`Camel case`)
  - MyName(`Pascal case`)
  - a3
  - VALUE
  - Int(`대문자와 소문자를 구분하기 때문에 사용 가능`)
  - initial_value
  - 합계 (C++11 이후 사용 가능)
  - 총_인원 (C++11 이후 사용 가능)
- 사용할 수 없는 식별자의 예
  - 4days - `숫자로 시작해서 사용할 수 없다.`
  - my name - `중간에 공백이 존재한다.`
  - my#name - `특수문자는 사용할 수 없다`
  - int - `키워드는 식별자 이름으로 사용할 수 없다.`
  - initial-value - `하이폰은 사용할 수 없다.`
  - min:value - `콜론 또한 사용할 수 없다.`



## 2. 기본 자료형 및 상수와 변수

#### (1) C++의 자료형

- 기본 자료형
  - 정수 자료형
    - char - 문자
    - int - 정수
    - short
    - long
    - bool - 참, 거짓
    - 등등
  - 실수 자료형
    - float
    - double
    - long double
- 복합 자료형
  - 배열, 구조체(struct), 클래스(class), 열거형(enum), 공용체(union)
  - 포인터, 참조

#### (2) C++의 기본 자료형 (1/2)

- 정수 자료형(integral types)
  - 고정 소수점 (fixed-point) 방식의 숫자 표현
    - `오버플로(overflow)`가 발생하지 않도록 주의해야 함
  -  문자를 표현하는 자료형
    - char (8bit)
  - 정수를 표현하는 자료형
    - int(16bit이며 항상 똑같지 않음 시대에 따라 달라짐) , short(16bit), long(32bit), long long(64bit)
  - signed 또는 unsigned
    - signed는 음수와 양수를 모두 표현 가능
    - unsigned는 양수만 표현 가능
  - 참 / 거짓을 표현하는 자료형
    - bool : true(참) 또는 false(거짓) 저장
    - 0 이면 거짓
    - 0 이 아니면 참

#### (2) C++의 기본 자료형 (2/2)

- 실수 자료형
  - 부동소수점(floating-pointer) 방식의 숫자 표현
  - float (4byte)
    - `부호 1비트, 지수부 8비트, 가수부 23비트`로 구성
    - 1.17549 x 10<sup>-38</sup> ~ 3.40282 x 10<sup>38</sup> 범위의 값을 표현함
  - double (8byte)
    - `부호 1비트, 지수부 11비트, 가수부 52비트`로 구성
    - 2.22507 x 10<sup>-308</sup> ~ 179769 x 10<sup>308</sup> 범위의 값을 표현함

#### (3) 상수의 표현 - 리터럴(literal) (1/5)

- 정수형 리터럴의 표현
  - 숫자를 표현하는 문자와 부호만으로 표현됨
    - 숫자를 표현하는 문자
      - '0'~'9'까지의 숫자
      - 10~15에 해당되는 16진수를 표현하기 위해 문자 'a'~'f'와 'A'~'F' 사용 가능

#### (3) 상수의 표현 - 리터럴(literal) (2/5)

- 정수형 리터럴의 표현

  - `접두사를 이용한 진법의 표현`

    | 표현         | 의미                |
    | ------------ | ------------------- |
    | 159          | 10진수 int형의 상수 |
    | `0b`10011111 | 2진                 |
    | `0`237       | 8진수 int형 상수    |
    | `0x`9f       | 16진수 int형 상수   |

#### (3) 상수의 표현 - 리터럴(literal) (3/5)

- 정수형 리터럴의 표현

  - 접미사를 이용한 정수 리터럴의 자료형 지정

    | 표현  | 자료형          |
    | ----- | --------------- |
    | 123   | int형           |
    | 123u  | unsigned int형  |
    | 123L  | long형          |
    | 123ul | unsigned long형 |
    | 123ll | long long형     |

#### (3) 상수의 표현 - 리터럴(literal) (4/5)

- 문자 리터럴의 표현
  - 작은 따옴표`(' ')`안에 문자를 표기하는 방법

  - 8진수나 16진수 문자 코드로 표기하는 방법

    | 표현   | 의미                                            |
    | ------ | ----------------------------------------------- |
    | 'A'    | 문자 'A' (ASCII 코드에 해당하는 정부 65와 동일) |
    | '\101' | 'A'와 동일함 (65의 8진수 표현)                  |
    | '\x41' | 'A'와 동일함 (65의 16진수 표현)                 |

#### (3) 상수의 표현 - 리터럴(literal) (5/5)

- 실수리터럴의 표현

  - 소수점의 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 'e'가 있으면 실수형 리터럴임

    | 표현                                    | 의미             |
    | --------------------------------------- | ---------------- |
    | 1200.<br />1200.0<br />12e2<br />1.2e+3 | double형 값 1200 |
    | 1200.0f<br />12e2f                      | float형 값 1200  |

#### (4) 변수 (1/4)

- 변수란?
  - 프로그램이 실행되는 동안 `기억하고 있어야 하는 값`들을 `저장`하는 `메모리 영역`
  - 변수에는 `이름이 지정`되어야 한다. (식별자의 규칙으로 지정)
  - 모든 변수는 `사용하기 전에 미리 선언`해야 한다.
- 변수 선언 위치
  - 함수 내부 👉🏻 `지역변수`
  - 함수 외부 👉🏻 `전역변수`

#### (4) 변수 (2/4)

- 변수 선언 형식

  - 형식 1.

    ```c++
    int size;
    // int 자료형 이름(int, float, double 등) 
    // size 변수의 이름
    ```

  - 형식 2.

    ```c++
    int size, price, stock;
    // int 자료형 이름(int, float, double 등) 
    // 동일 자료형의 여러 개의 변수 선언
    ```

#### (4) 변수 (3/4)

- 변수의 초기화

  - 형식 1.

    ```c++
    int total = 0;
    /* 
    	int total; // 선언
    	total = 0; // 대입
    	과 같지만
    	
    	int total = 0; 은 `초기화`이며
    	
    	total = 0; 은 `대입`이다.
    */
    ```

  - 형식 2.

    ```c++
    int total(0);
    // int total = 0; 과 같은 `초기화` 방법중 하나이다.
    int x = 1.5; // 1로 초기화 된다. (묵시적 형변환)
    // double에서 int형으로 `묵시적 형변환`이 이루어지며 int형은 소수점을 가질 수 없으므로,
    // 소수점을 버려서 1로 초기화 되는 것이다.
    float y(x); // x에서 이미 1로 초기화 되어있는 값을 넣어 준 거기 때문에 1로 초기화 된다.
    ```

  - 형식 3.

    ```c++
    int total = {0}; // (C++11 이후 사용 가능)
    // int total {0}으로 `=`을 생략할 수 있다.
    short x{total}; // 오류: 축소 변환
    // int는 16비트 컴퓨터에서는 16비트, 32비트, 64비트 에서는 32비트이다.
    // short는 16비트인데 해당하는 비트 수가 맞지 않기 때문에 엄격한 오류 체크를 해서 오류가 난다.
    float y{total}; // 오류: 축소 변환
    // {}은 자료형의 엄격함 하지만 오차의 범위를 잡아주기 때문에 이 점 유의해서 사용하자
    ```

#### (4) 변수 (4/4)

- 자료형 추론

  - 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론함

    ```c++
    auto i(10); // int i(10); 과 동일함
    // 10이란 값을 추론해서 int형으로 값의 자료형을 초기화 한다.
    // 이런것이 자료형의 추론이다.
    ```

#### (5) const와 constexpr (1/3)

- const 한정어

  - 변수의 값을 수정할 수 없게 함

  - `초기화를 통해서만 값을 정할 수 있음`

    ```c++
    const double PI {3.14159}; // 원주율 정의 (지향)
    ```

  - 비교

    ```c++
    #define PI 3.14159 // 매크로 상수 정의 (지양)
    ```

#### (5) const와 constexpr (2/3)

- constexpr 한정어

  - 그 값을 `컴파일 할 때 평가`한다는 의미

  - `실행 중 값을 평가하는 것에 비해 효율적으로 동작`할 수 있게함

    ```c++
    int a;
    std::cin >> a;
    const int b = 20;
    const int C1 = a;  		 	// cin을 통해 입력된 a의 값으로 초기화
    constexpr int C2 = a + 10; 	// 오류: 컴파일 시에 a의 값을 알 수 없음
    constexpr int C3 = b + 100; // b + 100을 컴파일 시에 계산할 수 있음
    constexpr int C4 = C1 * 2;	// 오류: 컴파일 시에 C1의 값을 알 수 없음
    ```

  - 간단하게 생각해서 입력을 받아야 되는 변수에 constexpr을 초기화하면 에러가 뜬다. 

  - 컴파일과 동시에 값이 정해져 있는 변수만 사용 해야한다.

#### (5) const와 constexpr (3/3)

- constexpr 함수

  - `모든 인수가 constexpr인 경우 컴파일 할 때 값을 구할 수 있게 함`

    ```c++
    constexpr int fac(int n) {
        return n > 1 ? n*f(n-1) : 1;
    }
    
    void f(int x) {
        constexpr int a = fac(4);	// 컴파일할 때 계싼
        int b = fac(x); 			// 실행 중 계산 (일반 함수처럼 실행)
    	......
    }
    ```

#### (6) 변수의 유효기간 (1/2)

- 변수의 유효기간(lifetime)이란?
  - 변수가 언제 만들어져서 언제 없어지는가를 나타냄
    - `자동 변수 (지역변수 개념)`
      - 생성 시점 : 함수(함수 안의 `블록`)가 시작될 때
      - 소멸 시점 : 함수(함수 안의 `블록`)가 종료될 때
    - `정적 변수 (전역변수 개념)`
      - 생성 시점 : 프로그램이 시작될 때
      - 소멸 시점 : 프로그램이 종료될 때

#### (6) 변수의 유효기간 (2/2)

- 변수의 유효기간(lifetime)이란?

  - 변수가 언제 만들어 져서 언제 없어지는가를 나타냄

    ```c++
    int x;				// 전역변수 - 정적 유효기간
    int f() {
        int y;			// 지역변수 - 자동 유효기간
        static int z;	// 정적 지역변수 - 정적 유효기간
       	...
    }
    ```

  - static을 붙이면 함수 내부에서 선언되더라도 정적(전역) 변수 개념으로 사용되어 진다.

#### (7) 변수와 상수 사용 예 - CircleArea.cpp

```c++
#include <iostream>
using namespace std;

int main()
{
	const double PI{ 3.14159 };				// 상수
	double redius;							// 변수

	cout << "원의 반경을 입력하시오 : ";
	cin >> redius;				

	double area = redius * redius * PI;
	cout << "원의 면적 = " << area << endl;
	return 0;
}
```



## 3. 연산자

#### (1) 산술 연산자 (1/2)

- 2항 연산자
  - 사칙 연산자 : + , - , * , /

    ```c++
    10 + 20
        // 10 , 20 피연산자
        // + 연산자
    ```

    | 수식      | 수식의 값                          |
    | --------- | ---------------------------------- |
    | 5 + 3     | 8                                  |
    | 3 / 2     | 1 (자료형에 따라 값이 달라진다.)   |
    | 3.0 / 2.0 | 1.5 (자료형에 따라 값이 달라진다.) |

    - 정수 / 정수 → 정수
    - 정수 / 실수 → 실수
    - 실수 / 정수 → 실수
    - 실수 / 실수 → 실수

  - 나머지 연산자 : % `(C, C++의 특징 외워두기)`

    | 수식    | 수식의 값 |
    | ------- | --------- |
    | 5 % 3   | 2         |
    | -5 % 3  | -2        |
    | 5 % -3  | 2         |
    | -5 % -3 | -2        |

#### (1) 산술 연산자 (2/2)

- 단항 연산자

  - 증, 감 연산자 : ++, --

    | 수식(a가 10일 때) | a의 값 | b의 값 |
    | ----------------- | ------ | ------ |
    | b = ++a;          | 11     | 11     |
    | b = a++;          | 11     | 10     |
    | b = --a;          | 9      | 9      |
| b = a--;          | 9      | 10     |
    
  - 부호 연산자 : +, -

#### (2) 대입 연산자 (1/2)

- 대인 연산자 (=)

  - 수식의 값 : 저장된 결과 (a는 double형, b는 int형일 때)

    | 수식        | 실행결과     |
    | ----------- | ------------ |
    | a = 0;      | a ← 0        |
    | a = b = 0;  | b ← 0, a ← 0 |
    | a = b = 1.5 | b ← 1, a ← 1 |

#### (2) 대입 연산자 (2/2)

- 복합 대입 연산자

  - 이항 연산자와 대입 연산자를 결합

  - +=, -=, *=, /=, %=, <<=, >>= 등

    | 수식    | 실행 결과          |
    | ------- | ------------------ |
    | a += b; | a = a + b; 와 동일 |

#### (3) 관계 연산자

- 관계 연산자

  - \>,  <, >=, <=, ==, != 

    | 수식 (a는 10, b는 -5일 때) | 수식의 값 |
    | -------------------------- | --------- |
    | a > b                      | true      |
    | a == 5                     | false     |

#### (4) 논리 연산자

- 논리 연산자
  - 논리 합 ||, 논리 곱 &&, 부정 !

    | 수식 (a 는 10, b 는 -5 일 때) | 수식의 값     |
    | ----------------------------- | ------------- |
    | a > 0 && b > 0                | false         |
    | a > 0 \|\| b > 0              | true          |
    | a < 0 && --b < 0              | false, b는 -5 |
    | !(a > 0)                      | false         |

#### (5) 비트 단위 연산자 (1/3)

- 비트 단위 논리 연산자

  - 논리 합 |, 논리 곱 &, 베타적 논리 합 ^, 부정 ~

  - x는 0x35(0011 0101), y는 0xf0(1111 0000) 일 때

    | 수식   | 수식의 값        |
    | ------ | ---------------- |
    | x \| y | 0xf5 (1111 0101) |
    | x & y  | 0x30 (0011 0000) |
    | x ^ y  | 0xc5 (1100 0101) |
    | ~x     | 0xca (1100 1010) |

#### (5) 비트 단위 연산자 (2/3)

- 비트 이동 연산자

  - 좌측 이동 << : 우측 피연산자에 지정된 비트 수 만큼 좌측 피연산자를 좌측으로 이동

    - 우측의 비는 비트에는 `0이 채워진다`

      ```c++
      unsigned char x = 0b00011101; // 29;
      unsigned char y = x << 2;	  // 0b01110100; => 116
      ```

#### (5) 비트 단위 연산자 (3/3)

- 비트 이동 연산자

  - 우측 이동 >> : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동

    - signed 형에 대해서는 부호를 유지할 수 있도록 `부호와 같은 비트`가 `좌측의 비는 비트에 채워짐 (구현에 따라 다름)`

      ```c++
      char x = 0b10010100; // -108 , 0이면 양, 1이면 음
      char y = x >> 2; 	 // 0b11100101 => -27
      ```

#### (6) 조건 연산자

- 유일한 3항 연산자

  - 조건 ? 값1 : 값2

    - `조건`이 true이면 수식의 값은 `값1`, false이면 `값2`

      | 수식 (a 는 10, b 는 20, c 는 30일 때) | 수식의 값 |
      | ------------------------------------- | --------- |
      | a > 0 ? b : c                         | 20        |



## 4. 자료형의 변환

#### (1) 묵시적 형 변환 (1/2)

- 묵시적 형 변환 개요
  - 두 값 사이의 연산에서는 우선순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 `같은 형으로 자동적으로 형 변환`됨 (컴파일러가 알아서 형변환 해준다.)
  - `더 큰 값을 표현할 수 있는쪽이 우선순위가 더 크다`
  - 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐
    - a + b + c + d
      - => ((( a + b ) + c ) + d ) 순서대로 이루어진다는 걸 나타냄
  - 대입 연산자(=)는 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함
    - `오차나 오버플로가 발생할 수 있으므로 주의해야 함`

#### (1) 묵시적 형 변환 (2/2)

- 묵시적 형 변환의 예

  ```c++
  intVar = doubleVar + intVar * floatVar;
  // 1. intVar * floatVar => float으로 묵시적 형 변환
  // 2. doubleVar + floatVar => double로 묵시적 형 변환
  // 3. intVar에 값을 넣어줘야 되기 때문에 int 형으로 묵시적 형 변환이 이루어진 후에 대입이 이루어진다.
  // 오차나 오버플로가 발생할 수 있다.
  ```

#### (2) 명시적 형 변환 (1/2)

- 형 변환 연산자
  - static_cast : 실행 중에 형 검사를 하지 않으며, 컴파일 할 때 `수식에 지정된 그대로 변환함`
  - dynamic_cast : 기초 클래스와 파생 클래스 간의 `포인터` 또는 `참조 형` 변환이 `프로그램 실행 중에 일어나도록 지시함`
  - `reinterpret_cast : 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함 (어쩔수 없을 때만 써야함)`
  - const_cast : const 지정을 일시 해제함

#### (2) 명시적 형 변환 (2/2)

- 형 변환 연산자 사용 형식

  ```c++
  static_cast<int> (n / 10.0)
      // static_cast - 형 변환 연산자
      // <int> - 변환하고자 하는 목표 자료형
      // (n / 10.0) - 형 변환 대상 수식
  ```

  





