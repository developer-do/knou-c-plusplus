# 6강. 클래스와 객체(2)



## 1. 디폴트 생성자

### (1) 디폴트 생성자의 개념

#### 디폴트 생성자(default constructor)란?

- 매새변수가 없는 생성자, 또는 모든 매개변수에 디폴트 인수가 지정된 생성자
- 클래스를 선언할 때 생성자를 선언하지 않으면 컴파일러는 묵시적으로 디폴트 생성자를 정의함
  - 묵시적 디폴트 생성자는 아무런 처리도 포함하지 않음
- 생성자를 하나라도 선언하면 컴파일러는 묵시적 생성자를 정의하지 않음



### (2) 디폴트 생성자의 활용 (1/4)

#### 묵시적 디폴트 생성자

- Counter.h

```c++
class Counter {
    int Value;
public:
    Counter() {} // 생성자를 만들지 않아도, 묵시적으로 생성자를 생성함
    void reset() {
        value = 0;
    }
    void count() {
        ++value;
    }
    int getValue() const {
        return value;
    }
}

int main() {
    Counter cnt; // 매개변수 없이 생성 가능
    // ......
}
```





### (2) 디폴트 생성자의 활용 (2/4)

#### 디폴트 생성자가 없는 클래스

- CounterM.h

```c++
class CounterM {
    const int maxValue;
    int value;
public:
    CounterM(int mVal) 
        : maxValue{mVal}, value{0} {}
    void reset() {
        value = 0;
    }
    void count() {
        value = value < maxValue ? value + 1 : 0;
    }
    // ......
}


int main() {
    CounterM cnt1(999);
    CounterM cnt2; // error 
}
```



### (2) 디폴트 생성자의 활용 (3/4)

#### 객체 배열의 선언

- Counter.h

```c++
class Counter {
    int Value;
public:
    // Counter() {}
    void reset() {
        value = 0;
    }
    void count() {
        ++value;
    }
    int getValue() const {
        return value;
    }
}


int main() {
    Counter cntArr[4];
    Counter *pt = new Counter[10];
    // ......
}
```





### (2) 디폴트 생성자의 활용 (4/4)

#### 객체 배열의 선언

- CounterM.h

```c++
class CounterM {
    const int maxValue;
    int value;
public:
    // CounterM의 디폴트 생성자 없음
	CounterM(int mVal)
        : maxValue{mVal}, value{0} {}
    void reset {
        value = 0;
    }
    // ......
}


int main() {
    CounterM cntMArr1[3]; // Error
    CounterM cntMArr2[3] = {CounterM(9), CounterM(99), CounterM(999)}; // OK
    CounterM *pt = new CounterM[10]; // Error
    // ......
}
```





## 2. 복사 생성자



### (1) 복사 생성자의 개념 (1/2)

#### 복사 생성자(copy constructor)란?

- 같은 클래스의 객체를 복사하여 객체를 만드는 생성자
- 묵시적 복사 생성자 : 객체의 데이터 멤버들을 그대로 복사하여 객체를 만들도록 묵시적으로 정의된 복사 생성자



#### 명시적으로 복사 생성자를 정의하는 형식

```c++
class ClassName {
    ......
public:
    ClassName(const ClassName& obj) {
        ...... // 생성되는 객체에 obj를 복사하는 처리
    }
}
```



### (1) 복사 생성자의 개념 (2/2)

#### 묵시적 복사 생성자

- CounterM.h

```c++
class CounterM {
    const int maxValue;
    int value;
public:
    CounterM (int mVal) 
        : maxValue{mVal}, value{0} {}
    
    /*
    묵시적으로 해당 인스턴스를 넣으면 참조하여 해당 인스턴스의 값을 대입한다.
	CounterM(const CounterM& c) :
		maxValue{c.maxValue},
		value{c.value} {}
    */
    
    
    void reset() {
        value = 0;
    }
}


int main() {
	CounterM cnt4{99};
    CounterM cnt5{cnt4}; // 99가 초기값이 된다.
    CounterM cnt6 = cnt4; // 두번째 문장과 동일하여 99가 초기값이 된다.
}
```





### (2) 얕은 복사의 문제점 - VecF 클래스 (1/5)

#### VecF 클래스

- 벡터 객체를 만들 수 있는 VecF 클래스를 정의하고자 한다. VecF 객체는 저장할 수 있는 float 값의 수를 인수로 지정하여 생성되며, 저장할 값의 배열이 제공될 경우 그 값으로 초기화한다. 인수로 전달된 VecF 객체와 덧셈한 결과를 반환할 수 있으며, 객체에 저장된 벡터를 출력할 수 있다.
- 행위

| 메소드                   | 비고                         |
| ------------------------ | ---------------------------- |
| VecF(int d, float* a)    | 생성자                       |
| ~VecF()                  | 소멸자                       |
| VecF add(const VecF& fv) | fv와 덧셈을 한 결과를 반환함 |
| void print()             | 벡터를 출력함                |

- 속성

| 속성       | 비고                   |
| ---------- | ---------------------- |
| int n      | 벡터의 크기를 저장함   |
| float *arr | 벡터의 저장공간 포인터 |



### (2) 얕은 복사의 문제점 - VecF.h (2, 3, 4/5)

```c++
#include <iostream>
#include <cstring>
using namespace std;

class VecF {
    int n;
    float *arr;
public:
    VecF(int d, const float* a = nullptr)  : n { d } { // 생성자
        arr = new float[d];
        if(a) memcpy(arr, a, sizeof(float) * n);
    }
    
    ~VecF() {
        delete[] arr;
    }
    
    VecF add(const VecF& fv) const {
        VecF tmp(n); // 벡터의 덧셈 결과를 저장할 임시 객체
        for(int i = 0; i < n; i++) {
            tmp.arr[i] = arr[i] + fv.arr[i];
        }
        return tmp; // 덧셈 결과를 반환함
    }
    
	void print() const {
        cout << "[ ";
        for(int i = 0; i < n; i++) {
            cout << arr[i] << " ";
        }
        cout << "]";
    }
};
```

### (2) 얕은 복사의 문제점 - VFMain1.cpp (5/5)

```c++
#include <iostream>
using namespace std;
#include "VecF.h"


int main() {
    float a[3] = {1,2,3};
    VecF v1(3, a); // 1,2,3을 저장하는 벡터
    VecF v2(v1);   // v1을 복사하여 v2를 만듦
    v1.print();    // 얕은 복사로 인한 에러 발생 - 아직 v2 객체가 삭제된 메모리 영역 v1쪽을 가리키고 있음
    cout << endl;
    v2.print(); 
    cout << endl;
    return 0;
}
```



